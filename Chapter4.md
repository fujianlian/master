# 交易

比特币交易是比特币系统中最重要的部分。比特币中的其他一切都是为了确保交易可以被创建、在网络上传播、验证，并最终添加到全局交易分类账本（区块链）中。比特币交易的本质是数据结构，这些数据结构是对比特币交易参与者价值传递的编码。比特币区块链是一本全局复式记账总账簿，每个比特币交易都是在比特币区块链上的一个公开记录。

## 交易的输入输出

比特币交易的基本组成部分是***交易输出transaction output***。 交易输出是比特币不可分割的基本组合，记录在区块链上，并被整个网络认可有效。 比特币全节点跟踪所有可找到的和可使用的输出，称为***“未花费的交易输出”（unspent transaction outputs）****，即UTXO。 所有UTXO的集合被称为*UTXO集，目前有数百万个UTXO。 当新的UTXO被创建，UTXO集就会变大，当UTXO被消耗时，UTXO集会随着缩小。每一个交易都代表UTXO集的变化（状态转换）。

一个UTXO可以是1“聪”（satoshi）的任意倍数（整数倍）。就像美元可以被分割成表示两位小数的“分”一样，比特币可以被分割成八位小数的“聪”。尽管UTXO可以是任意值，但一旦被创造出来，即不可分割。这是UTXO值得被强调的一个重要特性：UTXO的面值为“聪”的整数倍，是离散（不连续）且不可分割的价值单位，一个UTXO只能在一次交易中作为一个整体被消耗。

交易的输出与输入链存在一个例外，即被称为***“币基交易”（Coinbase Transaction）***的特殊交易，它是每个区块中的第一笔交易，这笔交易是由“赢家”矿工放置的，创造了支付给该矿工的全新比特币，作为挖矿奖励。这个特殊的币基交易不消耗UTXO，相反，它有一个称为“coinbase”的特殊类型的输入，这也就是为什么比特币可以在挖矿过程中被创造出来。

**Tips：** 输入和输出，先有那个呢？先有鸡还是先有蛋？严格来讲，先产生输出，因为创造新比特币的 “币基交易”没有输入，但它可以无中生有产生输出。

### 交易输出

UTXO集中的UTXO被每一个全节点比特币客户端追踪。 新的交易从UTXO集中消耗（花费）一个或多个输出。

交易输出包含两部分：

- 一定量的比特币，面值为“聪”（satoshis） ，是最小的比特币单位；
- 确定花费输出所需条件的加密难题（cryptographic puzzle）

这个加密难题也被称为锁定脚本(locking script), 见证脚本(witness script), 或脚本公钥 (scriptPubKey)。

#### 交易序列化 - 输出

当交易通过网络传输或在应用程序之间交换时，它们是***序列化***的。 序列化是将数据结构的内部表示转换为可以一次发送一个字节的格式（也称为字节流）的过程。 序列化最常用于编码通过网络传输或用于文件中存储的数据结构。 交易输出的序列化格式如表6-1所示：

表6-1交易输出序列化

| Size                    | Field               | Description                                                 |
| :---------------------- | :------------------ | :---------------------------------------------------------- |
| 8 bytes (little-endian) | Amount              | Bitcoin value in satoshis (10-8 bitcoin)                    |
| 1–9 bytes (VarInt)      | Locking-Script Size | Locking-Script length in bytes, to follow                   |
| Variable                | Locking-Script      | A script defining the conditions needed to spend the output |

Alice的交易，序列化十六进制表示

0100000001186f9f998a5aa6f048e51dd8419a14d8a0f1a8a2836dd734d2804fe65fa35779000000008b483045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e381301410484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adfffffffff02**60e31600000000001976a914ab68025513c3dbd2f7b92a94e0581f5d50f654e788acd0ef8000000000001976a9147f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a888ac** 00000000

这里有一些提示：

- 加粗显示的部分有两个输出，每个都如本节之前所述进行了序列化。
- 0.015比特币的价值是1,500,000 聪。 十六进制表示是16 e3 60。
- 在序列化交易中，值16 e3 60以小端（最低有效字节优先）字节顺序进行编码，所以它看起来像60 e3 16。
- scriptPubKey的长度为25个字节，十六进制显示为19。

### 交易输入

交易输入标识哪个UTXO（通过引用）将被消费，并通过解锁脚本提供所有权证明。

要构建一个交易，一个钱包从它控制的UTXO中选择足够的面值来支付请求的付款。 有时一个UTXO就足够，有时候需要不止一个。 对于用于付款的每个UTXO，钱包将创建一个指向该UTXO的输入，使用解锁脚本解锁它。

让我们更详细地看一下输入的组成内容。输入的第一部分是一个指向UTXO的指针，引用交易哈希和输出索引，这个索引标识了交易中的特定UTXO。 第二部分是解锁脚本，钱包构建它用以满足在UTXO中的支付条件。 大多数情况下，解锁脚本是一个证明比特币所有权的数字签名和公钥，但是并不是所有的解锁脚本都包含签名。 第三部分是序列号，稍后再讨论。

交易输入是一个名为 vin 的数组（列表）：

```bash
"vin": [
  {
    "txid": "7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18",
    "vout": 0,
    "scriptSig" : "3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf",
    "sequence": 4294967295
  }
]
```

如您所见，列表中只有一个输入（因为一个UTXO的面值足够完成付款）。 输入包含四个元素：

- 一个交易ID，引用包含将要消费的UTXO的交易
- 一个输出索引（vout），用于标识来自该交易的哪个UTXO被引用（第一个为零）
- 一个 scriptSig（解锁脚本），满足UTXO的消费条件，解锁用于支出
- 一个序列号（稍后讨论）

#### 交易序列化—交易输入

当交易被序列化在网络上传输时，它们的输入被编码成字节流，如下表所示

表6-2 交易输入序列化

| Size               | Field                 | Description                                                  |
| :----------------- | :-------------------- | :----------------------------------------------------------- |
| 32 bytes           | Transaction Hash      | Pointer to the transaction containing the UTXO to be spent   |
| 4 bytes            | Output Index          | The index number of the UTXO to be spent; first one is 0     |
| 1–9 bytes (VarInt) | Unlocking-Script Size | Unlocking-Script length in bytes, to follow                  |
| Variable           | Unlocking-Script      | A script that fulfills the conditions of the UTXO locking script |
| 4 bytes            | Sequence Number       | Used for locktime or disabled (0xFFFFFFFF)                   |

Alice的交易，序列化并以十六进制表示

0100000001**186f9f998a5aa6f048e51dd8419a14d8a0f1a8a2836dd734d2804fe65fa35779000000008b483045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e381301410484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adfffffffff**0260e31600000000001976a914ab68025513c3dbd2f7b92a94e0581f5d50f654e788acd0ef8000000000001976a9147f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a888ac00000 000

**提示：**

- 交易ID序列化后与原来的字节逆序呈现，因此以（十六进制）18开头，以79结尾
- 输出索引为4字节组的“0”，容易识别
- scriptSig的长度为139个字节，十六进制为8b
- 序列号设置为FFFFFFFF，也容易识别

### 交易费

大多数交易都包含交易费，这是对比特币矿工保护网络安全的补偿。交易费本身也是一种安全机制，增加攻击者向网络中大量发送交易的经济成本。

交易费用是一种激励措施，激励将交易纳入（挖矿）下一个区块，但通过对每笔交易收取小额费用，也起到抑制滥用系统的作用。交易费由成功挖到区块的矿工收取，该区块把交易记录在区块链上。

交易费是基于**交易的千字节（KB）大小来计算的（即交易费与交易的比特币金额无关）**，而不是交易比特币的价值。总的来说，交易费是根据比特币网络中的市场力量确定的。

交易费影响处理优先级，这意味着有足够费用的交易会更可能被打包进下一个挖出的区块中；反之交易费不足或者没有交易费的交易可能会被推迟，基于尽力而为的原则在几个区块之后被处理，甚至可能根本不被处理。交易费不是强制的，而且没有交易费的交易最终也可能会被处理，但是，有交易费会鼓励优先处理。

起初，交易费是固定的，是网络中的一个**固定常数**。随着网络容量和交易量的增加，收费结构逐渐放松，并可能受到市场力量的影响。至少从**2016年初**以来，比特币网络容量的限制已经造成交易之间的竞争，从而导致更高的费用，**免费交易彻底成为历史**。零费用（费用**低于0.0001比特币**的交易被视为零费用）或非常低费用的交易很少被处理，有时甚至不会在网络上传播。

**Tips：** 固定费用在比特币网络上不再可行。 设置固定费用的钱包将导致用户体验很差，因为交易往往会被“卡住”，不被确认。不了解比特币交易和费用的用户因交易被“卡住” 而感到沮丧，因为他们认为自己已经失去了这笔钱。

### 把交易费加到交易中

交易的数据结构没有交易费这个字段。相反，交易费是指输入和输出之间的差值。从所有输入中扣掉所有输出之后的剩余的金额是矿工收取的交易费：

```bash
Fees = Sum(Inputs) – Sum(Outputs)
```

举例来说，如果你消耗了一个20比特币的UTXO来完成1比特币的付款，你必须包含一笔19比特币的找零回到你的钱包。否则，那剩下的19比特币会被当作交易费，并将由挖出你交易的矿工收走。尽管你会得到高优先级的处理，并且让一个矿工喜出望外，但这一定不是你想要的结果。

**警告：** 如果你忘记了在手动构造的交易中增加找零的输出，系统会把找零当作交易费来处理。“不用找了！”也许不是你的真实意愿。

**实例计算：**Alice想花0.015比特币购买咖啡。为了确保这笔交易能被立即处理，Alice想添加一笔交易费，比如说0.001。这意味着总花费会变成0.016。因此她的钱包需要凑齐一些UXTO加起来是0.016比特币或更多金额。如果更多的话，就得加上找零。我们假设她的钱包有一个**0.2比特币（输入）**的UTXO可用。钱包就会消耗掉这个UTXO，创造一个新的**0.015的输出**给Bob的咖啡店，另一个**0.184比特币的输出**作为找零回到Alice的钱包，并留下未分配的0.001交易费作为交易的隐含费用。

```bash
Fees = 0.2 - 0.015 - 0.184 = 0.001
```

举例来说，如果你消耗了一个20比特币的UTXO来完成1比特币的付款，你必须包含一笔19比特币的找零回到你的钱包。否则，那剩下的19比特币会被当作交易费，并将由挖出你交易的矿工收走。尽管你会得到高优先级的处理，并且让一个矿工喜出望外，但这一定不是你想要的结果。

## 数字签名（ECDSA）

比特币中使用的数字签名算法是***椭圆曲线数字签名算法（Elliptic Curve Digital Signature Algorithm）***或*ECDSA*。 ECDSA是基于椭圆曲线私钥/公钥对用于数字签名的算法

数字签名在比特币中有三种用途：

- 签名证明私钥的所有者，即资金所有者，有权花费这些资金
- 授权证明是不可拒绝的（不可否认性）
- 签名证明交易（或交易的具体部分）在签字之后没有也不能被任何人修改

**注意：** 每个交易输入和它包含的任何签名完全独立于任何其他输入或签名。 多方可以协作构建交易，但是每方只能签名一个输入。

### 数字签名如何工作

#### 创建数字签名

在比特币的ECDSA算法的实现中，被签名的“消息”是交易，或更确切地说是交易中特定数据子集的哈希值。签名密钥是用户的私钥，结果就是签名：

**((Sig = F*{sig}(F*{hash}(m), dA)))**这里的：

- *dA* 是签名私钥
- *m* 是交易（或其部分）
- *Fhash* 是散列函数
- *Fsig* 是签名算法
- *Sig* 是结果签名

函数*Fsig* 产生由两个值组成的签名Sig，通常称为R和S：

```bash
Sig = (R, S)
```

现在已经计算了两个值R和S，它们就使用一种称为*可分辨编码规则Distinguished Encoding Rules*或*DER*的国际标准编码方案，序列化为字节流。

#### 签名序列化（DER）

我们再来看看Alice创建的交易。 在交易输入中有一个解锁脚本，其中包含Alice的钱包中的以下DER编码签名：

```
3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e381301
```

该签名是Alice的钱包生成的R和S值的序列化字节流，证明她拥有授权花费该输出的私钥。 序列化格式包含以下9个元素：

- *0x30*表示DER序列的开始
- *0x45* - 序列的长度（69字节）
- *0x02* - 一个整数值
- *0x21* - 整数的长度（33字节）
- *00884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb* - **R值**
- *0x02* - 接下来是一个整数
- *0x20* - 整数的长度（32字节）
- *4b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813* - **S值**
- 后缀（*0x01*）指示使用的哈希的类型（SIGHASH_ALL）

看看您是否可以使用此列表解码 Alice 的序列化（DER编码）签名。 重要的数字是**R和S**; 数据的其余部分是DER编码方案的一部分。

### 验证签名

要验证签名，必须有签名（*R*和*S*）、序列化交易和公钥（对应于用于创建签名的私钥）。本质上，签名的验证意味着“只有生成此公钥的私钥的所有者，才能在此交易上产生此签名。”

签名验证算法采用消息（交易或其部分的哈希值）、签名者的公钥和签名（R和S值），如果签名对该消息和公钥有效，则返回 TRUE 值。

### ECDSA数学

如前所述，签名由数学函数*Fsig* 创建，该函数生成了由*R*和*S*两个值组成的签名。在本节中，我们将更详细查看*Fsig* 函数。

签名算法首先生成一个 *短暂的ephemeral*（临时的）私公钥对。 该临时密钥对用于在涉及签名私钥和交易哈希的转换之后计算*R*和*S*值。

临时密钥对基于随机数*k*，后者用作临时私钥。 从*k*，生成相应的临时公钥*P*（以P = k *G计算，与派生比特币公钥相同）;参见[【4.1.4 公钥】](https://github.com/tianmingyun/MasterBitcoin2CN/blob/master/ch04.md#414-公钥)部分）。数字签名的*R*值则是临时公钥*P*的x坐标。

在此基础上，算法计算签名的*S*值，使得：

S = k-1 (Hash(m) + dA * R) mod n

其中：

- *k*是临时私钥
- *R*是临时公钥的x坐标
- *dA*是签名私钥
- *m*是交易数据
- *n*是椭圆曲线的阶

验证是签名生成函数的倒数，使用R，S值和公钥来计算值P，该值是椭圆曲线上的一个点（签名创建时使用的临时公钥）：

P = S-1 *Hash(m)* G + S-1 *R* Qa

其中：

- *R*和*S*是签名值
- *Qa*是Alice的公钥
- *m*是签名的交易数据
- *G*是椭圆曲线生成点

如果计算出的点*P*的*x*坐标等于*R*，则验证者就得出结论，签名是有效的。

请注意，在验证签名时，私钥既不知道也不会泄露。

### 随机性在签名中的重要性

签名生成算法使用随机密钥*k*作为临时私有公钥对的基础。 *k* 的值不重要，只要它是随机的。如果使用相同的*k*值用在不同的消息（交易）上生成两个签名，则任何人都可以计算签名私钥。**在签名算法中使用相同的 *k* 值会导致私钥泄露！**

> **警告** 如果在两个不同的交易中，签名算法使用相同的 *k*值，则私钥就能被计算出来，暴露给全世界！

